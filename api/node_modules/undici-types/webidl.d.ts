// These types are not exported, and are only used internally
<<<<<<< HEAD
import * as undici from './index'
=======
>>>>>>> upstream/main

/**
 * Take in an unknown value and return one that is of type T
 */
type Converter<T> = (object: unknown) => T

<<<<<<< HEAD
type SequenceConverter<T> = (object: unknown, iterable?: IterableIterator<T>) => T[]
=======
type SequenceConverter<T> = (object: unknown) => T[]
>>>>>>> upstream/main

type RecordConverter<K extends string, V> = (object: unknown) => Record<K, V>

interface ConvertToIntOpts {
  clamp?: boolean
  enforceRange?: boolean
}

interface WebidlErrors {
<<<<<<< HEAD
  /**
   * @description Instantiate an error
   */
  exception (opts: { header: string, message: string }): TypeError
  /**
   * @description Instantiate an error when conversion from one type to another has failed
=======
  exception (opts: { header: string, message: string }): TypeError
  /**
   * @description Throw an error when conversion from one type to another has failed
>>>>>>> upstream/main
   */
  conversionFailed (opts: {
    prefix: string
    argument: string
    types: string[]
  }): TypeError
  /**
   * @description Throw an error when an invalid argument is provided
   */
  invalidArgument (opts: {
    prefix: string
    value: string
    type: string
  }): TypeError
}

<<<<<<< HEAD
interface WebIDLTypes {
  UNDEFINED: 1,
  BOOLEAN: 2,
  STRING: 3,
  SYMBOL: 4,
  NUMBER: 5,
  BIGINT: 6,
  NULL: 7
  OBJECT: 8
}

=======
>>>>>>> upstream/main
interface WebidlUtil {
  /**
   * @see https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
   */
<<<<<<< HEAD
  Type (object: unknown): WebIDLTypes[keyof WebIDLTypes]

  TypeValueToString (o: unknown):
=======
  Type (object: unknown):
>>>>>>> upstream/main
    | 'Undefined'
    | 'Boolean'
    | 'String'
    | 'Symbol'
    | 'Number'
    | 'BigInt'
    | 'Null'
    | 'Object'

<<<<<<< HEAD
  Types: WebIDLTypes

=======
>>>>>>> upstream/main
  /**
   * @see https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
   */
  ConvertToInt (
    V: unknown,
    bitLength: number,
    signedness: 'signed' | 'unsigned',
    opts?: ConvertToIntOpts
  ): number

  /**
<<<<<<< HEAD
   * @see https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
   */
  IntegerPart (N: number): number

  /**
   * Stringifies {@param V}
   */
  Stringify (V: any): string

  MakeTypeAssertion <I>(I: I): (arg: any) => arg is I

  /**
   * Mark a value as uncloneable for Node.js.
   * This is only effective in some newer Node.js versions.
   */
  markAsUncloneable (V: any): void
=======
   * @see https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
   */
  IntegerPart (N: number): number
>>>>>>> upstream/main
}

interface WebidlConverters {
  /**
   * @see https://webidl.spec.whatwg.org/#es-DOMString
   */
<<<<<<< HEAD
  DOMString (V: unknown, prefix: string, argument: string, opts?: {
=======
  DOMString (V: unknown, opts?: {
>>>>>>> upstream/main
    legacyNullToEmptyString: boolean
  }): string

  /**
   * @see https://webidl.spec.whatwg.org/#es-ByteString
   */
<<<<<<< HEAD
  ByteString (V: unknown, prefix: string, argument: string): string
=======
  ByteString (V: unknown): string
>>>>>>> upstream/main

  /**
   * @see https://webidl.spec.whatwg.org/#es-USVString
   */
  USVString (V: unknown): string

  /**
   * @see https://webidl.spec.whatwg.org/#es-boolean
   */
  boolean (V: unknown): boolean

  /**
   * @see https://webidl.spec.whatwg.org/#es-any
   */
  any <Value>(V: Value): Value

  /**
   * @see https://webidl.spec.whatwg.org/#es-long-long
   */
  ['long long'] (V: unknown): number

  /**
   * @see https://webidl.spec.whatwg.org/#es-unsigned-long-long
   */
  ['unsigned long long'] (V: unknown): number

  /**
   * @see https://webidl.spec.whatwg.org/#es-unsigned-long
   */
  ['unsigned long'] (V: unknown): number

  /**
   * @see https://webidl.spec.whatwg.org/#es-unsigned-short
   */
  ['unsigned short'] (V: unknown, opts?: ConvertToIntOpts): number

  /**
   * @see https://webidl.spec.whatwg.org/#idl-ArrayBuffer
   */
  ArrayBuffer (V: unknown): ArrayBufferLike
  ArrayBuffer (V: unknown, opts: { allowShared: false }): ArrayBuffer

  /**
   * @see https://webidl.spec.whatwg.org/#es-buffer-source-types
   */
  TypedArray (
    V: unknown,
    TypedArray: NodeJS.TypedArray | ArrayBufferLike
  ): NodeJS.TypedArray | ArrayBufferLike
  TypedArray (
    V: unknown,
    TypedArray: NodeJS.TypedArray | ArrayBufferLike,
    opts?: { allowShared: false }
  ): NodeJS.TypedArray | ArrayBuffer

  /**
   * @see https://webidl.spec.whatwg.org/#es-buffer-source-types
   */
  DataView (V: unknown, opts?: { allowShared: boolean }): DataView

  /**
   * @see https://webidl.spec.whatwg.org/#BufferSource
   */
  BufferSource (
    V: unknown,
    opts?: { allowShared: boolean }
  ): NodeJS.TypedArray | ArrayBufferLike | DataView

  ['sequence<ByteString>']: SequenceConverter<string>
<<<<<<< HEAD

=======
  
>>>>>>> upstream/main
  ['sequence<sequence<ByteString>>']: SequenceConverter<string[]>

  ['record<ByteString, ByteString>']: RecordConverter<string, string>

<<<<<<< HEAD
  /**
  * @see https://fetch.spec.whatwg.org/#requestinfo
  */
  RequestInfo (V: unknown): undici.Request | string

  /**
   * @see https://fetch.spec.whatwg.org/#requestinit
   */
  RequestInit (V: unknown): undici.RequestInit

  [Key: string]: (...args: any[]) => unknown
}

type WebidlIsFunction<T> = (arg: any) => arg is T

interface WebidlIs {
  Request: WebidlIsFunction<undici.Request>
  Response: WebidlIsFunction<undici.Response>
  ReadableStream: WebidlIsFunction<ReadableStream>
  Blob: WebidlIsFunction<Blob>
  URLSearchParams: WebidlIsFunction<URLSearchParams>
  File: WebidlIsFunction<File>
  FormData: WebidlIsFunction<undici.FormData>
  URL: WebidlIsFunction<URL>
  WebSocketError: WebidlIsFunction<undici.WebSocketError>
  AbortSignal: WebidlIsFunction<AbortSignal>
  MessagePort: WebidlIsFunction<MessagePort>
  USVString: WebidlIsFunction<string>
}

=======
  [Key: string]: (...args: any[]) => unknown
}

>>>>>>> upstream/main
export interface Webidl {
  errors: WebidlErrors
  util: WebidlUtil
  converters: WebidlConverters
<<<<<<< HEAD
  is: WebidlIs
=======
>>>>>>> upstream/main

  /**
   * @description Performs a brand-check on {@param V} to ensure it is a
   * {@param cls} object.
   */
<<<<<<< HEAD
  brandCheck <Interface extends new () => unknown>(V: unknown, cls: Interface): asserts V is Interface

  brandCheckMultiple <Interfaces extends (new () => unknown)[]> (list: Interfaces): (V: any) => asserts V is Interfaces[number]
=======
  brandCheck <Interface>(V: unknown, cls: Interface, opts?: { strict?: boolean }): asserts V is Interface
>>>>>>> upstream/main

  /**
   * @see https://webidl.spec.whatwg.org/#es-sequence
   * @description Convert a value, V, to a WebIDL sequence type.
   */
  sequenceConverter <Type>(C: Converter<Type>): SequenceConverter<Type>

  illegalConstructor (): never

  /**
   * @see https://webidl.spec.whatwg.org/#es-to-record
   * @description Convert a value, V, to a WebIDL record type.
   */
  recordConverter <K extends string, V>(
    keyConverter: Converter<K>,
    valueConverter: Converter<V>
  ): RecordConverter<K, V>

  /**
   * Similar to {@link Webidl.brandCheck} but allows skipping the check if third party
   * interfaces are allowed.
   */
<<<<<<< HEAD
  interfaceConverter <Interface>(typeCheck: WebidlIsFunction<Interface>, name: string): (
    V: unknown,
    prefix: string,
    argument: string
  ) => asserts V is Interface
=======
  interfaceConverter <Interface>(cls: Interface): (
    V: unknown,
    opts?: { strict: boolean }
  ) => asserts V is typeof cls
>>>>>>> upstream/main

  // TODO(@KhafraDev): a type could likely be implemented that can infer the return type
  // from the converters given?
  /**
   * Converts a value, V, to a WebIDL dictionary types. Allows limiting which keys are
   * allowed, values allowed, optional and required keys. Auto converts the value to
   * a type given a converter.
   */
  dictionaryConverter (converters: {
    key: string,
<<<<<<< HEAD
    defaultValue?: () => unknown,
=======
    defaultValue?: unknown,
>>>>>>> upstream/main
    required?: boolean,
    converter: (...args: unknown[]) => unknown,
    allowedValues?: unknown[]
  }[]): (V: unknown) => Record<string, unknown>

  /**
   * @see https://webidl.spec.whatwg.org/#idl-nullable-type
   * @description allows a type, V, to be null
   */
  nullableConverter <T>(
    converter: Converter<T>
  ): (V: unknown) => ReturnType<typeof converter> | null

<<<<<<< HEAD
  argumentLengthCheck (args: { length: number }, min: number, context: string): void
=======
  argumentLengthCheck (args: { length: number }, min: number, context: {
    header: string
    message?: string
  }): void
>>>>>>> upstream/main
}
